<html>

<head>
    <meta name="viewport" content="width=970; height=1505; user-scalable=no">
    <link rel="manifest" href="manifest.json">
    <style>
        html,
        body {
            overflow-x: hidden;
            overflow-y: hidden;
        }

        html {
            overflow: hidden;
        }

        body {
            overflow: hidden;
            position: relative;
            margin: 0;
            padding: 0;
        }

        body {
            margin: 0;
            background: #111111;
            overscroll-behavior: none;
            position: relative;
        }
    </style>
</head>

<body>

    <canvas></canvas>
    <script src="js/socket.io.dev.js"></script>
    <script>



        window.addEventListener("scroll", preventMotion, false);
        window.addEventListener("touchmove", preventMotion, false);

        function preventMotion(event) {
            window.scrollTo(0, 0);
            event.preventDefault();
            event.stopPropagation();
        }

        function clearHUDElements() {
            controllers = [];
            texts = [];
            buttons = [];
            c.clearRect(0, 0, innerWidth, innerHeight);

        }



        var timeDeltas = [];
        var url = window.location.hostname + ':80/client'

        var socket = io(url);

        // socket.on('connect', function () {
        //     socket.join(socket.id);
        // });

        // FIXME: USELESS
        // socket.on('TimeReturn', function (data) {
        //     var now = Date.now();
        //     var then = new Date(data);

        //     // console.log((now - then) / 2);
        //     timeDeltas.push((now - then) / 2);
        // });

        // var average = function (thing) {
        //     let sum = thing.reduce((previous, current) => current += previous);
        //     let length = thing.length;
        //     let avg = sum / length;
        //     console.log('Out of ' + length + ' entries, the average is ' + avg + ' with a sum of ' + sum);
        // }

    </script>
    <script>

        // socket.on('connect', function (thesocket) {
        //     const adminSocket = io(url+'/'+socket.id);
        //     console.log(adminSocket);
        // });

        var canvas = document.querySelector('canvas');
        var c = canvas.getContext('2d');

        var controllers = [];
        var texts = [];
        var buttons = [];

        var touches = [];
        var touchesObject = {};
        var width = window.innerWidth;
        var height = window.innerHeight;

        function init() {
            canvas.width = width;
            canvas.height = height;
            // alert(width + ', ' + height)
        }

        init();

        window.addEventListener('resize', function () {
            width = window.innerWidth;
            height = window.innerHeight;
            init();
        });


        function getSmallestScreenDimention() {
            return width > height ? height : width
        }

        class VirtualElement {
            constructor(elementId, xPosition, yPosition) {
                this.elementId = elementId;
                this.xPosition = xPosition;
                this.yPosition = yPosition;
            }

            draw() {
                // Draw
            }
        };

        class VirtualText extends VirtualElement {
            constructor(elementId, xPosition, yPosition, text, textColour, textAlign, textFont, size) {
                super(elementId, xPosition, yPosition);
                this.text = text;
                this.textAlign = textAlign;
                this.textColour = textColour;
                this.fillFont = size + 'px ' + textFont
            }

            draw() {
                c.font = this.fillFont;
                c.fillStyle = this.textColour;
                c.textAlign = this.textAlign;
                c.fillText(this.text, this.xPosition, this.yPosition);
            }
        }


        class VirtualButton extends VirtualElement {
            constructor(elementId, xPosition, yPosition, radius, text) {
                super(elementId, xPosition, yPosition);
                this.radius = radius;
                this.text = text;
                this.pressed = false;
            }

            press() {
                this.pressed = true;
                socket.emit('VirtualButtonUpdate', {
                    'id': this.elementId,
                    "event": "press"
                });
                this.draw();
            }


            release() {
                // alert('released')
                this.pressed = false;
                socket.emit('VirtualButtonUpdate', {
                    'id': this.elementId,
                    "event": "release"
                });
                this.draw();
            }

            draw() {
                // Draw circle
                c.beginPath();
                c.arc(this.xPosition, this.yPosition, this.radius, 0, 2 * Math.PI);
                c.strokeStyle = "#b0b0b0";
                c.lineWidth = 30;
                c.stroke();

                if (!this.pressed) {
                    c.fillStyle = "#616161";
                } else {
                    c.fillStyle = "#cccccc";
                }

                c.fill();

                c.font = '40px Arial';
                c.fillStyle = 'white';
                c.textAlign = 'center';
                c.fillText(this.text, this.xPosition, this.yPosition);
            }
        }



        // Virtual Controller Class
        function VirtualController(elementId, xPosition, yPosition, controllerRadius, pointerRadius, vertical, horizonal) {
            this.elementId = elementId;
            this.xPosition = xPosition;
            this.yPosition = yPosition;
            this.controllerRadius = controllerRadius;
            this.pointerRadius = pointerRadius;
            this.vertical = vertical;
            this.horizonal = horizonal;
            this.xPointer = xPosition;
            this.yPointer = yPosition;

            this.xRelPointer = (this.xPointer - this.xPosition) / this.controllerRadius;
            this.yRelPointer = (this.yPointer - this.yPosition) / this.controllerRadius;

            this.isTouched = false;
            this.socketEmitter = null;

            this.startIntervalEmitter = () => {
                this.socketEmitter = setInterval(() => {
                    this.emitCurrentPointer();
                }, 30);
            }

            this.stopIntervalEmitter = () => {
                clearInterval(this.socketEmitter);
            }

            this.stopEmitter = () => {
                this.stopIntervalEmitter();
                clearInterval(this.socketEmitter);
                this.emit(this.elementId, 0, 0);
            }

            this.emitCurrentPointer = () => {
                this.emit(this.elementId, this.xRelPointer, this.yRelPointer);
            }

            this.emit = (elementId, xRelPointer, yRelPointer) => {
                // Socket.io
                socket.emit('VirtualControllerUpdate', {
                    'id': elementId,
                    'xRelPointer': xRelPointer,
                    'yRelPointer': yRelPointer
                });
            }

            this.draw = function () {
                this.drawController();
                this.drawPointer();
            }

            this.drawController = function () {
                c.beginPath();
                c.arc(this.xPosition, this.yPosition, this.controllerRadius, 0, Math.PI * 2, false)
                c.strokeStyle = 'rgba(255,255,255,0.75)';
                c.fillStyle = 'rgba(255,255,255,0.75)';
                c.fill();
                c.stroke();
            }

            this.drawPointer = function () {
                c.beginPath();
                c.arc(this.xPointer, this.yPointer, this.pointerRadius, 0, Math.PI * 2, false)
                c.strokeStyle = 'rgba(25,25,25,1)';
                c.fillStyle = 'rgb(0,0,0)';
                c.fill();
                c.stroke();
            }

            this.updatePointerData = function (xTouch, yTouch) {

                // If touch is inside a controller
                if (Math.pow(xTouch - this.xPosition, 2) + Math.pow(yTouch - this.yPosition, 2) < Math.pow(this.controllerRadius, 2)) {
                    this.xPointer = xTouch;
                    this.yPointer = yTouch;
                } else {
                    // Detect where the pointer should be IF NOT inside the circle
                    var secondAnswer = Math.sqrt(Math.pow(xTouch - this.xPosition, 2) + Math.pow(yTouch - this.yPosition, 2));
                    this.xPointer = (this.xPosition) + this.controllerRadius * ((xTouch - this.xPosition) / secondAnswer);
                    this.yPointer = (this.yPosition) + this.controllerRadius * ((yTouch - this.yPosition) / secondAnswer);
                }

                this.xRelPointer = (this.xPointer - this.xPosition) / this.controllerRadius;
                this.yRelPointer = (this.yPointer - this.yPosition) / this.controllerRadius;
                // alert(this.xRelPointer);

                // FIXME: Old latency testing.
                // var date = new Date();
                // socket.emit('Time', date);

                this.drawPointer();
            }

            this.resetPointerData = function () {
                this.updatePointerData(this.xPosition, this.yPosition);
            }

        }


        function animate() {

            requestAnimationFrame(animate);
            c.clearRect(0, 0, innerWidth, innerHeight);

            controllers.forEach(function (ele) {
                ele.draw();
            });

            texts.forEach(function (ele) {
                ele.draw();
            });

            buttons.forEach(function (ele) {
                ele.draw();
            });
        }


        // set to true if desktop is allowed
        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
            // Is a MOBILE device!
            // controllers.push(new VirtualController((width / 2), (height / 4), 300, 50, true, true));
            // controllers.push(new VirtualController((width / 2), (height / 4) * 3, 300, 50, true, true));

            socket.on('ForceRefresh', (data) => {
                texts.push(new VirtualText('99', width * 0.5, height * 0.5, 'Please refresh your device.', 'white', 'center', 'Arial', '50'))
                location.reload();
            });

            socket.on('NewHUDLayout', (data) => {
                clearHUDElements();

                data.HUDElements.forEach(element => {
                    switch (element.type) {
                        case 'Analogue':
                            if (element.relative) {
                                controllers.push(new VirtualController(element.id, width * element.xPosition, height * element.yPosition, element.radius, element.pointerRadius, true, true));
                            } else {
                                controllers.push(new VirtualController(element.id, element.xPosition, element.yPosition, element.radius, element.pointerRadius, true, true));
                            }
                            break;
                        case 'Text':
                            if (element.relative) {
                                texts.push(new VirtualText(element.id, width * element.xPosition, height * element.yPosition, element.text, element.textColour, element.textAlign, element.textFont, element.textSize))
                            }
                            break;
                        case 'Button':
                            if (element.relative) {
                                buttons.push(new VirtualButton(element.id, width * element.xPosition, height * element.yPosition, element.radius, element.text))
                            }
                            break;
                        default:
                            console.error('Recieved an unknown HUD element.')
                            break;
                    }
                });
            });



            socket.on('ServerDisconnected', data => {
                clearHUDElements();
            });
            animate();


            //startSimulation and pauseSimulation defined elsewhere
            function handleVisibilityChange() {
                if (document.hidden) {
                    // socket.close();
                    alert('Because the browser lost focus, you have lost control of the current game. Refresh to join again.');
                } else {
                }
            }

            document.addEventListener("visibilitychange", handleVisibilityChange, false);



        } else {
            alert('This is not a mobile device :(');
            window.location.replace("../");
        }












        //////////////////////////////////////////////////////////
        ////////////////////// TOUCH EVENTS //////////////////////
        //////////////////////////////////////////////////////////


        // touchstart Touch Event
        canvas.addEventListener('touchstart', function (event) {

            // Flags "controller" to false, unless touch is inside controller
            controller = false;
            button = false;


            // Check to see if pointer is inside ANY of the virtual controller ranges
            for (var index = 0; index < controllers.length; index++) {
                // (point_x - center_circle_x)^2 + (point_y - center_circle_y)^2 < circle_radius^2
                // Algorithm from: https://stackoverflow.com/questions/481144/equation-for-testing-if-a-point-is-inside-a-circle

                // If touch is inside a controller, flag item in touch array
                if (Math.pow(event.changedTouches[0].pageX - controllers[index].xPosition, 2) + Math.pow(event.changedTouches[0].pageY - controllers[index].yPosition, 2) < Math.pow(controllers[index].controllerRadius, 2)) {
                    controller = controllers[index];
                    controller.startIntervalEmitter();
                    // Controllers shouldn't overlap, therefor touch can be in ONLY ONE controller
                    break;
                }
            }


            for (var index = 0; index < buttons.length; index++) {
                if (Math.pow(event.changedTouches[0].pageX - buttons[index].xPosition, 2) + Math.pow(event.changedTouches[0].pageY - buttons[index].yPosition, 2) < Math.pow(buttons[index].radius, 2)) {
                    button = buttons[index];
                    button.press();
                    // alert(JSON.stringify(button));
                    // Buttons shouldn't overlap, therefor touch can be in ONLY ONE button
                    break;
                }
            }

            touchesObject[event.changedTouches[0].identifier] = {
                identifier: event.changedTouches[0].identifier,
                startPosition: {
                    x: event.changedTouches[0].pageX,
                    y: event.changedTouches[0].pageY,
                    controller: controller ? controller : false,
                    button: button ? button : false
                },
                currentPosition: {
                    x: event.changedTouches[0].pageX,
                    y: event.changedTouches[0].pageY,
                },
            };

            // alert(JSON.stringify(touchesObject))

            // touches.push({
            //     identifier: event.changedTouches[0].identifier,
            //     startPosition: {
            //         x: event.changedTouches[0].pageX,
            //         y: event.changedTouches[0].pageY,
            //         controller: controller ? controller : false
            //     },
            //     currentPosition: {
            //         x: event.changedTouches[0].pageX,
            //         y: event.changedTouches[0].pageY,
            //     },
            // });
        });

        // touchmove Touch Event
        canvas.addEventListener('touchmove', function (event) {

            // controllers[0].updatePointerData(event.changedTouches[0].pageX, event.changedTouches[0].pageY)

            for (var changeIndex = 0; changeIndex < event.changedTouches.length; changeIndex++) {

                // var touch = touches.find(touch => touch.identifier === event.changedTouches[changeIndex].identifier);

                // IF the touch was initiated INSIDE a controller, update said controllers pointer (which socket-updates server)
                if (touchesObject[event.changedTouches[changeIndex].identifier].startPosition.controller) {
                    touchesObject[event.changedTouches[changeIndex].identifier].startPosition.controller.updatePointerData(event.changedTouches[changeIndex].pageX, event.changedTouches[changeIndex].pageY)
                }

            }



            // console.log(event.changedTouches.length);

            // // Go through all changed touches to update 
            // for (var changeIndex = 0; changeIndex < event.changedTouches.length; changeIndex++) {
            //     // For each touch, find index in array from touch identifier
            //     var touchArrayIndex = touches.findIndex(touch => touch.identifier === event.changedTouches[changeIndex].identifier);

            //     // Once found, update known data in touches array
            //     touches[touchArrayIndex].currentPosition.x = event.changedTouches[changeIndex].pageX;
            //     touches[touchArrayIndex].currentPosition.y = event.changedTouches[changeIndex].pageY;

            //     // Find if touch started INSIDE controller
            //     // if (event.changedTouches[changeIndex].startPosition.insideController) {
            //     // TODO: 
            //     // UPDATE THE CONTROLLER POINT AND POST CONTENT TO WEBSOCKETS
            //     // }
            // }
            // Outline:
            // Go through ALL changed touches to see if ANY started INSIDE a virtual controller
        });

        // touchend Touch Event
        canvas.addEventListener('touchend', function (event) {
            // touches = touches.filter(touch => touch.identifier !== event.changedTouches[0].identifier);


            if (touchesObject[event.changedTouches[0].identifier].startPosition.button) {
                // BUTTON
                touchesObject[event.changedTouches[0].identifier].startPosition.button.release();

            } else if (touchesObject[event.changedTouches[0].identifier].startPosition.controller) {
                // CONTROLLER
                touchesObject[event.changedTouches[0].identifier].startPosition.controller.resetPointerData();
                touchesObject[event.changedTouches[0].identifier].startPosition.controller.stopEmitter();
            }

            delete touchesObject[event.changedTouches[0].identifier];
        });




        // FROM: https://developers.google.com/web/fundamentals/native-hardware/fullscreen
        function toggleFullScreen() {
            var doc = window.document;
            var docEl = doc.documentElement;

            var requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
            var cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

            if (!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
                requestFullScreen.call(docEl);
            }
            else {
                cancelFullScreen.call(doc);
            }
            init();
        }



        // Old Code
        // function createController(x, y, radius) {
        //     c.beginPath();
        //     c.arc(x, y, radius, 0, Math.PI * 2, false)
        //     c.strokeStyle = 'rgba(255,255,255,0.75)';
        //     c.fillStyle = 'rgba(255,255,255,0.75)';
        //     c.fill();
        //     c.stroke();
        //     controllers.push({
        //         centre: {
        //             x: x,
        //             y: y
        //         },
        //         radius: radius
        //     });
        // }

        // createController((width / 2), (height / 2), 200)


        ///////// LEGACY FUNCTION //////////

        // function Text(elementId, xPosition, yPosition, text, colour, textAlign, font, size) {
        //     this.elementId = elementId;
        //     this.xPosition = xPosition;
        //     this.yPosition = yPosition;
        //     this.text = text;
        //     this.textAlign = textAlign;
        //     this.colour = colour;
        //     this.fillFont = size + 'px ' + font

        //     this.draw = function () {
        //         c.font = "30px Comic Sans MS";
        //         c.fillStyle = this.colour;
        //         c.textAlign = this.textAlign;
        //         c.fillText(this.text, canvas.width / 2, canvas.height / 2);
        //     }
        // }



        ///////// LEGACY FUNCTION //////////


        // Virtual Controller Class
        // function VirtualController(elementId, xPosition, yPosition, controllerRadius, pointerRadius, vertical, horizonal) {
        //     this.elementId = elementId;
        //     this.xPosition = xPosition;
        //     this.yPosition = yPosition;
        //     this.controllerRadius = controllerRadius;
        //     this.pointerRadius = pointerRadius;
        //     this.vertical = vertical;
        //     this.horizonal = horizonal;
        //     this.xPointer = xPosition;
        //     this.yPointer = yPosition;

        //     this.xRelPointer = (this.xPointer - this.xPosition) / this.controllerRadius;
        //     this.yRelPointer = (this.yPointer - this.yPosition) / this.controllerRadius;

        //     this.isTouched = false;
        //     this.socketEmitter = null;

        //     this.startIntervalEmitter = () => {
        //         this.socketEmitter = setInterval(() => {
        //             this.emitCurrentPointer();
        //         }, 30);
        //     }

        //     this.stopIntervalEmitter = () => {
        //         clearInterval(this.socketEmitter);
        //     }

        //     this.stopEmitter = () => {
        //         this.stopIntervalEmitter();
        //         clearInterval(this.socketEmitter);
        //         this.emit(this.elementId, 0, 0);
        //     }

        //     this.emitCurrentPointer = () => {
        //         this.emit(this.elementId, this.xRelPointer, this.yRelPointer);
        //     }

        //     this.emit = (elementId, xRelPointer, yRelPointer) => {
        //         // Socket.io
        //         socket.emit('VirtualControllerUpdate', {
        //             'id': elementId,
        //             'xRelPointer': xRelPointer,
        //             'yRelPointer': yRelPointer
        //         });
        //     }

        //     this.draw = function () {
        //         this.drawController();
        //         this.drawPointer();
        //     }

        //     this.drawController = function () {
        //         c.beginPath();
        //         c.arc(this.xPosition, this.yPosition, this.controllerRadius, 0, Math.PI * 2, false)
        //         c.strokeStyle = 'rgba(255,255,255,0.75)';
        //         c.fillStyle = 'rgba(255,255,255,0.75)';
        //         c.fill();
        //         c.stroke();
        //     }

        //     this.drawPointer = function () {
        //         c.beginPath();
        //         c.arc(this.xPointer, this.yPointer, this.pointerRadius, 0, Math.PI * 2, false)
        //         c.strokeStyle = 'rgba(25,25,25,1)';
        //         c.fillStyle = 'rgb(0,0,0)';
        //         c.fill();
        //         c.stroke();
        //     }

        //     this.updatePointerData = function (xTouch, yTouch) {

        //         // If touch is inside a controller
        //         if (Math.pow(xTouch - this.xPosition, 2) + Math.pow(yTouch - this.yPosition, 2) < Math.pow(this.controllerRadius, 2)) {
        //             this.xPointer = xTouch;
        //             this.yPointer = yTouch;
        //         } else {
        //             // Detect where the pointer should be IF NOT inside the circle
        //             var secondAnswer = Math.sqrt(Math.pow(xTouch - this.xPosition, 2) + Math.pow(yTouch - this.yPosition, 2));
        //             this.xPointer = (this.xPosition) + this.controllerRadius * ((xTouch - this.xPosition) / secondAnswer);
        //             this.yPointer = (this.yPosition) + this.controllerRadius * ((yTouch - this.yPosition) / secondAnswer);
        //         }

        //         this.xRelPointer = (this.xPointer - this.xPosition) / this.controllerRadius;
        //         this.yRelPointer = (this.yPointer - this.yPosition) / this.controllerRadius;
        //         // alert(this.xRelPointer);

        //         // FIXME: Old latency testing.
        //         // var date = new Date();
        //         // socket.emit('Time', date);

        //         this.drawPointer();
        //     }

        //     this.resetPointerData = function () {
        //         this.updatePointerData(this.xPosition, this.yPosition);
        //     }

        // }






//         // touchstart Touch Event
//         canvas.addEventListener('touchstart', function (event) {

// // Flags "controller" to false, unless touch is inside controller
// controller = false;

// // Check to see if pointer is inside ANY of the virtual controller ranges
// for (var index = 0; index < controllers.length; index++) {
//     // (point_x - center_circle_x)^2 + (point_y - center_circle_y)^2 < circle_radius^2
//     // Algorithm from: https://stackoverflow.com/questions/481144/equation-for-testing-if-a-point-is-inside-a-circle

//     // If touch is inside a controller, flag item in touch array
//     if (Math.pow(event.changedTouches[0].pageX - controllers[index].xPosition, 2) + Math.pow(event.changedTouches[0].pageY - controllers[index].yPosition, 2) < Math.pow(controllers[index].controllerRadius, 2)) {
//         controller = controllers[index];
//         controller.startIntervalEmitter();
//         // Controllers shouldn't overlap, therefor touch can be in ONLY ONE controller
//         break;
//     }
// }

// touchesObject[event.changedTouches[0].identifier] = {
//     identifier: event.changedTouches[0].identifier,
//     startPosition: {
//         x: event.changedTouches[0].pageX,
//         y: event.changedTouches[0].pageY,
//         controller: controller ? controller : false
//     },
//     currentPosition: {
//         x: event.changedTouches[0].pageX,
//         y: event.changedTouches[0].pageY,
//     },
// };

// // touches.push({
// //     identifier: event.changedTouches[0].identifier,
// //     startPosition: {
// //         x: event.changedTouches[0].pageX,
// //         y: event.changedTouches[0].pageY,
// //         controller: controller ? controller : false
// //     },
// //     currentPosition: {
// //         x: event.changedTouches[0].pageX,
// //         y: event.changedTouches[0].pageY,
// //     },
// // });
// });

    </script>
</body>

</html>